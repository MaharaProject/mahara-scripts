#!/usr/bin/perl -w

# Takes a Mahara .po file generated by php-po.php, and converts it
# into a Mahara language pack containing help files (html) and string
# files (php).

# Assumes the .po reference comments contain either an html filename
# or a php filename followed by a space and a mahara language string
# key.

# po-php.pl /path/to/po/files/fr-1.3_STABLE.po /path/to/langpacks/fr.utf8 fr.utf8

use File::Path qw(mkpath);
use File::Basename qw(fileparse);
use Locale::PO;
use FindBin;

my ($inputfile, $outputdir, $lang) = @ARGV;

# The version of Locale::PO on chatter (0.17) spews warnings for all
# the msgctxt lines in the file.  Should remove this later.
BEGIN { $SIG{'__WARN__'} = sub { warn $_[0] if substr($_[0], 0, 15) ne "Strange line in" } }

my $strings = Locale::PO->load_file_asarray($inputfile);

my %htmlfiles = ();
my %phpfiles = ();

my $plural = undef;

foreach my $po (@$strings) {
    my $content = $po->msgstr();
    my $content_n = $po->msgstr_n();
    next if ( ! defined $content  && ! defined $content_n );

    if ( defined $content ) {
        # A normal, non-pluralised translation
        $content =~ s{\\n}{\n}g;
        next if ( $content eq '' || $content eq '""' );
    }
    if ( defined $content_n ) {
        # A translation with multiple plural forms
        my $anything = 0;
        foreach my $k ( keys %$content_n ) {
            $content_n->{$k} =~ s{\\n}{\n}g;
            $anything ||= ($content_n->{$k} ne '' && $content_n->{$k} ne '""');
        }
        next if ! $anything;
    }

    my $reference = $po->reference();

    if ( ! defined $reference ) {
        # Look for "Plural-Forms:" po header
        if ( ! defined $plural ) {
            my $msgid = $po->msgid();
            next if ( defined $msgid && $msgid ne '""' && $msgid ne '' );
            if ( $content =~ m{\nPlural-Forms:\s*nplurals\s*=\s*\d+\s*;\s*plural\s*=\s*(.+?)[\s;]*\n} ) {
                $plural = $1;
            }
        }
        next;
    }

    if ($reference =~ m{^(\S*lang/)\S+\.utf8(/\S+)\.html$}) {
        my $filename = $1 . $lang . $2 . '.html';
        # $content =~ $po->dequote($content);
        # dequote won't do multiline strings
        $content =~ s{^"(.*)"$}{$1}s;
        $content =~ s{\\"}{"}gs;
        $htmlfiles{$filename} = $content;
    }
    elsif ($reference =~ m{^(\S*lang/)\S+\.utf8(/\S+)\.php\s+(\S+)$}) {
        my $key = $3;
        my $filename = $1 . $lang . $2 . '.php';

        # Some things in langconfig.php are fairly meta, and probably
        # shouldn't form part of the translation.  For now, just
        # remove pluralrule & pluralfunction - we'll overwrite them
        # based on the Plural-Forms: header, or the hardcoded list.
        if ($2 eq 'langconfig' && ($key eq 'pluralrule' || $key eq 'pluralfunction')) {
            next;
        }

        # Normal non-plural string.
        if ( defined $content ) {
            $phpfiles{$filename}->{$key}->{msgstr} = fixquotes($content);
            next;
        }

        # Plural forms (in $content_n)
        $phpfiles{$filename}->{$key}->{msgstr_n} = {};
        foreach my $k ( keys %$content_n ) {
            $phpfiles{$filename}->{$key}->{msgstr_n}->{$k} = fixquotes($content_n->{$k});
        }
    }
}

foreach my $htmlfile (keys %htmlfiles) {
    my ($filename, $subdir, $suffix) = fileparse($htmlfile);
    my $dir = $outputdir . '/' . $subdir;
    mkpath($dir);
    open(my $fh, '>', "$dir/$filename");
    print $fh $htmlfiles{$htmlfile};
    close $fh;
}

foreach my $phpfile (keys %phpfiles) {
    my ($filename, $subdir, $suffix) = fileparse($phpfile);
    my $dir = $outputdir . '/' . $subdir;
    mkpath($dir);
    open(my $fh, '>', "$dir/$filename");
    print $fh "<?php\n\ndefined('INTERNAL') || die();\n\n";
    foreach my $key (sort keys %{$phpfiles{$phpfile}}) {
        if ( $phpfiles{$phpfile}->{$key}->{msgstr} ) {
            print $fh "\$string['$key'] = " . $phpfiles{$phpfile}->{$key}->{msgstr} . ";\n";
        }
        elsif ( $phpfiles{$phpfile}->{$key}->{msgstr_n} ) {
            print $fh "\$string['$key'] = array(\n";
            foreach my $k ( sort keys %{$phpfiles{$phpfile}->{$key}->{msgstr_n}} ) {
                print $fh "    $k => $phpfiles{$phpfile}->{$key}->{msgstr_n}->{$k},\n";
            }
            print $fh ");\n";
        }
    }
    close $fh;
}

# Write plural forms into langconfig.php
my $langshort = $lang;
$langshort =~ s/^([a-zA-Z_]+)\.utf8/$1/;

if ( ! defined $plural ) {
    # If there was no "Plural-Forms:" po header, read plural forms
    # rule from hardcoded list in pluralforms.pl
    open (my $fh, '<', "perl $FindBin::Bin/pluralforms.pl $langshort");
    $plural = <$fh>;
    close $fh;
}

if ( defined $plural && $plural =~ m/\S+/ ) {
    open(my $fh, '>>', "$outputdir/lang/$lang/langconfig.php");
    $plural =~ s{[']+}{}g;
    my $pluralphp = $plural;
    $pluralphp =~ s{n}{\$n}g;
    print $fh <<EOF;

// Plural forms, added by language pack generator
\$string['pluralrule'] = '$plural';
\$string['pluralfunction'] = 'plural_${langshort}_utf8';
function plural_${langshort}_utf8(\$n) {
    return $pluralphp;
}
EOF
    close $fh;
}

sub fixquotes {
    my $content = shift;
    # Output with single quotes or variables get interpolated
    if ( $content =~ m{^".*"$}s ) {
        $content =~ s{'}{\\'}gs;
        $content =~ s{^"(.*)"$}{'$1'}s;
        $content =~ s{\\"}{"}gs;
    }
    return $content;
}
